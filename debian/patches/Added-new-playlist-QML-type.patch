From 6c6d265a89d4e125297fe780cf1970db408e5974 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Lo=C3=AFc=20Molinari?= <loic.molinari@canonical.com>
Date: Wed, 5 Aug 2015 12:21:15 +0200
Subject: [PATCH] Added new playlist QML type.

Change-Id: I0788cc9719f427457ad0be9c9a5bfda00451a0c4
Reviewed-by: Yoann Lopes <yoann.lopes@theqtcompany.com>
---
 src/imports/multimedia/Video.qml                |  11 +
 src/imports/multimedia/multimedia.cpp           |   6 +
 src/imports/multimedia/multimedia.pro           |   2 +
 src/imports/multimedia/qdeclarativeaudio.cpp    |  83 +++-
 src/imports/multimedia/qdeclarativeaudio_p.h    |  10 +
 src/imports/multimedia/qdeclarativeplaylist.cpp | 583 ++++++++++++++++++++++++
 src/imports/multimedia/qdeclarativeplaylist_p.h | 199 ++++++++
 src/multimedia/doc/src/qtmultimedia-index.qdoc  |   6 +
 8 files changed, 897 insertions(+), 3 deletions(-)
 create mode 100644 src/imports/multimedia/qdeclarativeplaylist.cpp
 create mode 100644 src/imports/multimedia/qdeclarativeplaylist_p.h

diff --git a/src/imports/multimedia/Video.qml b/src/imports/multimedia/Video.qml
index f609c3f..fda8768 100644
--- a/src/imports/multimedia/Video.qml
+++ b/src/imports/multimedia/Video.qml
@@ -282,10 +282,21 @@ Item {
         \qmlproperty url Video::source
 
         This property holds the source URL of the media.
+
+        Setting the \l source property clears the current \l playlist, if any.
     */
     property alias source:          player.source
 
     /*!
+        \qmlproperty Playlist Video::playlist
+
+        This property holds the playlist used by the media player.
+
+        Setting the \l playlist property resets the \l source to an empty string.
+    */
+    property alias playlist:        player.playlist
+
+    /*!
         \qmlproperty enumeration Video::status
 
         This property holds the status of media loading. It can be one of:
diff --git a/src/imports/multimedia/multimedia.cpp b/src/imports/multimedia/multimedia.cpp
index 652359f..4dcb7c6 100644
--- a/src/imports/multimedia/multimedia.cpp
+++ b/src/imports/multimedia/multimedia.cpp
@@ -45,6 +45,7 @@
 #include "qdeclarativeaudio_p.h"
 #include "qdeclarativeradio_p.h"
 #include "qdeclarativeradiodata_p.h"
+#include "qdeclarativeplaylist_p.h"
 #include "qdeclarativecamera_p.h"
 #include "qdeclarativecamerapreviewprovider_p.h"
 #include "qdeclarativecameraexposure_p.h"
@@ -114,6 +115,11 @@ public:
         qmlRegisterUncreatableType<QDeclarativeCameraImageProcessing, 1>(uri, 5, 5, "CameraImageProcessing", trUtf8("CameraImageProcessing is provided by Camera"));
         qmlRegisterRevision<QDeclarativeCamera, 2>(uri, 5, 5);
 
+        // 5.6 types
+        qmlRegisterRevision<QDeclarativeAudio, 1>(uri, 5, 6);
+        qmlRegisterType<QDeclarativePlaylist>(uri, 5, 6, "Playlist");
+        qmlRegisterType<QDeclarativePlaylistItem>(uri, 5, 6, "PlaylistItem");
+
         qmlRegisterType<QDeclarativeMediaMetaData>();
         qmlRegisterType<QAbstractVideoFilter>();
     }
diff --git a/src/imports/multimedia/multimedia.pro b/src/imports/multimedia/multimedia.pro
index 71358ca..606fb39 100644
--- a/src/imports/multimedia/multimedia.pro
+++ b/src/imports/multimedia/multimedia.pro
@@ -3,6 +3,7 @@ QT += qml quick network multimedia-private qtmultimediaquicktools-private
 HEADERS += \
         qdeclarativeaudio_p.h \
         qdeclarativemediametadata_p.h \
+        qdeclarativeplaylist_p.h \
         qdeclarativeradio_p.h \
         qdeclarativeradiodata_p.h \
         qdeclarativecamera_p.h \
@@ -20,6 +21,7 @@ HEADERS += \
 SOURCES += \
         multimedia.cpp \
         qdeclarativeaudio.cpp \
+        qdeclarativeplaylist.cpp \
         qdeclarativeradio.cpp \
         qdeclarativeradiodata.cpp \
         qdeclarativecamera.cpp \
diff --git a/src/imports/multimedia/qdeclarativeaudio.cpp b/src/imports/multimedia/qdeclarativeaudio.cpp
index bb1af91..60af623 100644
--- a/src/imports/multimedia/qdeclarativeaudio.cpp
+++ b/src/imports/multimedia/qdeclarativeaudio.cpp
@@ -42,6 +42,7 @@
 #include <qmetadatareadercontrol.h>
 #include <qmediaavailabilitycontrol.h>
 
+#include "qdeclarativeplaylist_p.h"
 #include "qdeclarativemediametadata_p.h"
 
 #include <QTimerEvent>
@@ -99,11 +100,13 @@ void QDeclarativeAudio::_q_availabilityChanged(QMultimedia::AvailabilityStatus)
 
 QDeclarativeAudio::QDeclarativeAudio(QObject *parent)
     : QObject(parent)
+    , m_playlist(0)
     , m_autoPlay(false)
     , m_autoLoad(true)
     , m_loaded(false)
     , m_muted(false)
     , m_complete(false)
+    , m_emitPlaylistChanged(false)
     , m_loopCount(1)
     , m_runningCount(0)
     , m_position(0)
@@ -154,6 +157,45 @@ QUrl QDeclarativeAudio::source() const
     return m_source;
 }
 
+QDeclarativePlaylist *QDeclarativeAudio::playlist() const
+{
+    return m_playlist;
+}
+
+void QDeclarativeAudio::setPlaylist(QDeclarativePlaylist *playlist)
+{
+    if (playlist == m_playlist && m_source.isEmpty())
+        return;
+
+    if (!m_source.isEmpty()) {
+        m_source.clear();
+        emit sourceChanged();
+    }
+
+    m_playlist = playlist;
+    m_content = m_playlist ?
+        QMediaContent(m_playlist->mediaPlaylist(), QUrl(), false) : QMediaContent();
+    m_loaded = false;
+    if (m_complete && (m_autoLoad || m_content.isNull() || m_autoPlay)) {
+        if (m_error != QMediaPlayer::ServiceMissingError && m_error != QMediaPlayer::NoError) {
+            m_error = QMediaPlayer::NoError;
+            m_errorString = QString();
+
+            emit errorChanged();
+        }
+
+        if (!playlist)
+            m_emitPlaylistChanged = true;
+        m_player->setMedia(m_content, 0);
+        m_loaded = true;
+    }
+    else
+        emit playlistChanged();
+
+    if (m_autoPlay)
+        m_player->play();
+}
+
 bool QDeclarativeAudio::autoPlay() const
 {
     return m_autoPlay;
@@ -171,9 +213,14 @@ void QDeclarativeAudio::setAutoPlay(bool autoplay)
 
 void QDeclarativeAudio::setSource(const QUrl &url)
 {
-    if (url == m_source)
+    if (url == m_source && m_playlist == NULL)
         return;
 
+    if (m_playlist) {
+        m_playlist = NULL;
+        emit playlistChanged();
+    }
+
     m_source = url;
     m_content = m_source.isEmpty() ? QMediaContent() : m_source;
     m_loaded = false;
@@ -430,6 +477,16 @@ void QDeclarativeAudio::seek(int position)
     \qmlproperty url QtMultimedia::Audio::source
 
     This property holds the source URL of the media.
+
+    Setting the \l source property clears the current \l playlist, if any.
+*/
+
+/*!
+    \qmlproperty Playlist QtMultimedia::Audio::playlist
+
+    This property holds the playlist used by the media player.
+
+    Setting the \l playlist property resets the \l source to an empty string.
 */
 
 /*!
@@ -655,8 +712,8 @@ void QDeclarativeAudio::classBegin()
             this, SLOT(_q_statusChanged()));
     connect(m_player, SIGNAL(mediaStatusChanged(QMediaPlayer::MediaStatus)),
             this, SLOT(_q_statusChanged()));
-    connect(m_player, SIGNAL(mediaChanged(QMediaContent)),
-            this, SIGNAL(sourceChanged()));
+    connect(m_player, SIGNAL(mediaChanged(const QMediaContent&)),
+            this, SLOT(_q_mediaChanged(const QMediaContent&)));
     connect(m_player, SIGNAL(durationChanged(qint64)),
             this, SIGNAL(durationChanged()));
     connect(m_player, SIGNAL(positionChanged(qint64)),
@@ -757,6 +814,16 @@ void QDeclarativeAudio::_q_statusChanged()
     }
 }
 
+void QDeclarativeAudio::_q_mediaChanged(const QMediaContent &media)
+{
+    if (!media.playlist() && !m_emitPlaylistChanged) {
+        emit sourceChanged();
+    } else {
+        m_emitPlaylistChanged = false;
+        emit playlistChanged();
+    }
+}
+
 /*!
     \qmlproperty string QtMultimedia::Audio::errorString
 
@@ -1250,6 +1317,16 @@ void QDeclarativeAudio::_q_statusChanged()
     \qmlproperty url QtMultimedia::MediaPlayer::source
 
     This property holds the source URL of the media.
+
+    Setting the \l source property clears the current \l playlist, if any.
+*/
+
+/*!
+    \qmlproperty Playlist QtMultimedia::MediaPlayer::playlist
+
+    This property holds the playlist used by the media player.
+
+    Setting the \l playlist property resets the \l source to an empty string.
 */
 
 /*!
diff --git a/src/imports/multimedia/qdeclarativeaudio_p.h b/src/imports/multimedia/qdeclarativeaudio_p.h
index d4840f2..eef7054 100644
--- a/src/imports/multimedia/qdeclarativeaudio_p.h
+++ b/src/imports/multimedia/qdeclarativeaudio_p.h
@@ -58,6 +58,7 @@ class QMediaPlayerControl;
 class QMediaService;
 class QMediaServiceProvider;
 class QMetaDataReaderControl;
+class QDeclarativePlaylist;
 class QDeclarativeMediaBaseAnimation;
 class QDeclarativeMediaMetaData;
 class QMediaAvailabilityControl;
@@ -66,6 +67,7 @@ class QDeclarativeAudio : public QObject, public QQmlParserStatus
 {
     Q_OBJECT
     Q_PROPERTY(QUrl source READ source WRITE setSource NOTIFY sourceChanged)
+    Q_PROPERTY(QDeclarativePlaylist *playlist READ playlist WRITE setPlaylist NOTIFY playlistChanged REVISION 1)
     Q_PROPERTY(int loops READ loopCount WRITE setLoopCount NOTIFY loopCountChanged)
     Q_PROPERTY(PlaybackState playbackState READ playbackState NOTIFY playbackStateChanged)
     Q_PROPERTY(bool autoPlay READ autoPlay WRITE setAutoPlay NOTIFY autoPlayChanged)
@@ -155,6 +157,9 @@ public:
     QUrl source() const;
     void setSource(const QUrl &url);
 
+    QDeclarativePlaylist *playlist() const;
+    void setPlaylist(QDeclarativePlaylist *playlist);
+
     int loopCount() const;
     void setLoopCount(int loopCount);
 
@@ -192,6 +197,8 @@ public Q_SLOTS:
     void seek(int position);
 
 Q_SIGNALS:
+    Q_REVISION(1) void playlistChanged();
+
     void sourceChanged();
     void autoLoadChanged();
     void loopCountChanged();
@@ -229,15 +236,18 @@ private Q_SLOTS:
     void _q_error(QMediaPlayer::Error);
     void _q_availabilityChanged(QMultimedia::AvailabilityStatus);
     void _q_statusChanged();
+    void _q_mediaChanged(const QMediaContent&);
 
 private:
     Q_DISABLE_COPY(QDeclarativeAudio)
 
+    QDeclarativePlaylist *m_playlist;
     bool m_autoPlay;
     bool m_autoLoad;
     bool m_loaded;
     bool m_muted;
     bool m_complete;
+    bool m_emitPlaylistChanged;
     int m_loopCount;
     int m_runningCount;
     int m_position;
diff --git a/src/imports/multimedia/qdeclarativeplaylist.cpp b/src/imports/multimedia/qdeclarativeplaylist.cpp
new file mode 100644
index 0000000..bb785aa
--- /dev/null
+++ b/src/imports/multimedia/qdeclarativeplaylist.cpp
@@ -0,0 +1,583 @@
+/****************************************************************************
+**
+** Copyright (C) 2015 The Qt Company Ltd.
+** Contact: http://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see http://www.qt.io/terms-conditions. For further
+** information use the contact form at http://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** As a special exception, The Qt Company gives you certain additional
+** rights. These rights are described in The Qt Company LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qdeclarativeplaylist_p.h"
+
+QT_BEGIN_NAMESPACE
+
+/*!
+    \qmltype PlaylistItem
+    \instantiates QDeclarativePlaylistItem
+    \since 5.6
+
+    \inqmlmodule QtMultimedia
+    \ingroup multimedia_qml
+    \ingroup multimedia_audio_qml
+    \ingroup multimedia_video_qml
+    \brief Defines an item in a Playlist.
+
+    \sa Playlist
+*/
+
+/*!
+    \qmlproperty url QtMultimedia::PlaylistItem::source
+
+    This property holds the source URL of the item.
+
+    \sa Playlist
+*/
+QDeclarativePlaylistItem::QDeclarativePlaylistItem(QObject *parent)
+    : QObject(parent)
+{
+}
+
+QUrl QDeclarativePlaylistItem::source() const
+{
+    return m_source;
+}
+
+void QDeclarativePlaylistItem::setSource(const QUrl &source)
+{
+    m_source = source;
+}
+
+/*!
+    \qmltype Playlist
+    \instantiates QDeclarativePlaylist
+    \since 5.6
+    \brief For specifying a list of media to be played.
+
+    \inqmlmodule QtMultimedia
+    \ingroup multimedia_qml
+    \ingroup multimedia_audio_qml
+    \ingroup multimedia_video_qml
+
+    The Playlist type provides a way to play a list of media with the MediaPlayer, Audio and Video
+    types. It can be used as a data source for view elements (such as ListView) and other elements
+    that interact with model data (such as Repeater). When used as a data model, each playlist
+    item's source URL can be accessed using the \c source role.
+
+    \qml
+    import QtQuick 2.0
+    import QtMultimedia 5.6
+
+    Item {
+        width: 400;
+        height: 300;
+
+        Audio {
+            id: player;
+            playlist: Playlist {
+                id: playlist
+                PlaylistItem { source: "song1.ogg"; }
+                PlaylistItem { source: "song2.ogg"; }
+                PlaylistItem { source: "song3.ogg"; }
+            }
+        }
+
+        ListView {
+            model: playlist;
+            delegate: Text {
+                font.pixelSize: 16;
+                text: source;
+            }
+        }
+
+        MouseArea {
+            anchors.fill: parent;
+            onPressed: {
+                if (player.playbackState != Audio.PlayingState) {
+                    player.play();
+                } else {
+                    player.pause();
+                }
+            }
+        }
+    }
+    \endqml
+
+    \sa MediaPlayer, Audio, Video
+*/
+
+void QDeclarativePlaylist::_q_mediaAboutToBeInserted(int start, int end)
+{
+    emit itemAboutToBeInserted(start, end);
+
+    beginInsertRows(QModelIndex(), start, end);
+}
+
+void QDeclarativePlaylist::_q_mediaInserted(int start, int end)
+{
+    endInsertRows();
+
+    emit itemCountChanged();
+    emit itemInserted(start, end);
+}
+
+void QDeclarativePlaylist::_q_mediaAboutToBeRemoved(int start, int end)
+{
+    emit itemAboutToBeRemoved(start, end);
+
+    beginRemoveRows(QModelIndex(), start, end);
+}
+
+void QDeclarativePlaylist::_q_mediaRemoved(int start, int end)
+{
+    endRemoveRows();
+
+    emit itemCountChanged();
+    emit itemRemoved(start, end);
+}
+
+void QDeclarativePlaylist::_q_mediaChanged(int start, int end)
+{
+    emit dataChanged(createIndex(start, 0), createIndex(end, 0));
+    emit itemChanged(start, end);
+}
+
+void QDeclarativePlaylist::_q_loadFailed()
+{
+    m_error = m_playlist->error();
+    m_errorString = m_playlist->errorString();
+
+    emit error(Error(m_error), m_errorString);
+    emit errorChanged();
+    emit loadFailed();
+}
+
+QDeclarativePlaylist::QDeclarativePlaylist(QObject *parent)
+    : QAbstractListModel(parent)
+    , m_playlist(0)
+    , m_error(QMediaPlaylist::NoError)
+    , m_readOnly(false)
+{
+}
+
+QDeclarativePlaylist::~QDeclarativePlaylist()
+{
+    delete m_playlist;
+}
+
+/*!
+    \qmlproperty enumeration QtMultimedia::Playlist::playbackMode
+
+    This property holds the order in which items in the playlist are played.
+
+    \table
+    \header \li Value \li Description
+    \row \li CurrentItemOnce
+        \li The current item is played only once.
+    \row \li CurrentItemInLoop
+        \li The current item is played repeatedly in a loop.
+    \row \li Sequential
+        \li Playback starts from the current and moves through each successive item until the last
+           is reached and then stops. The next item is a null item when the last one is currently
+           playing.
+    \row \li Loop
+        \li Playback restarts at the first item after the last has finished playing.
+    \row \li Random
+        \li Play items in random order.
+    \endtable
+ */
+QDeclarativePlaylist::PlaybackMode QDeclarativePlaylist::playbackMode() const
+{
+    return PlaybackMode(m_playlist->playbackMode());
+}
+
+void QDeclarativePlaylist::setPlaybackMode(PlaybackMode mode)
+{
+    if (playbackMode() == mode)
+        return;
+
+    m_playlist->setPlaybackMode(QMediaPlaylist::PlaybackMode(mode));
+}
+
+/*!
+    \qmlproperty url QtMultimedia::Playlist::currentItemsource
+
+    This property holds the source URL of the current item in the playlist.
+ */
+QUrl QDeclarativePlaylist::currentItemSource() const
+{
+    return m_playlist->currentMedia().canonicalUrl();
+}
+
+/*!
+    \qmlproperty int QtMultimedia::Playlist::currentIndex
+
+    This property holds the position of the current item in the playlist.
+ */
+int QDeclarativePlaylist::currentIndex() const
+{
+    return m_playlist->currentIndex();
+}
+
+void QDeclarativePlaylist::setCurrentIndex(int index)
+{
+    if (currentIndex() == index)
+        return;
+
+    m_playlist->setCurrentIndex(index);
+}
+
+/*!
+    \qmlproperty int QtMultimedia::Playlist::itemCount
+
+    This property holds the number of items in the playlist.
+ */
+int QDeclarativePlaylist::itemCount() const
+{
+    return m_playlist->mediaCount();
+}
+
+/*!
+    \qmlproperty bool QtMultimedia::Playlist::readOnly
+
+    This property indicates if the playlist can be modified.
+ */
+bool QDeclarativePlaylist::readOnly() const
+{
+    // There's no signal to tell whether or not the read only state changed, so we consider it fixed
+    // after its initial retrieval in componentComplete().
+    return m_readOnly;
+}
+
+/*!
+    \qmlproperty enumeration QtMultimedia::Playlist::error
+
+    This property holds the error condition of the playlist.
+
+    \table
+    \header \li Value \li Description
+    \row \li NoError
+        \li No errors
+    \row \li FormatError
+        \li Format error.
+    \row \li FormatNotSupportedError
+        \li Format not supported.
+    \row \li NetworkError
+        \li Network error.
+    \row \li AccessDeniedError
+        \li Access denied error.
+    \endtable
+ */
+QDeclarativePlaylist::Error QDeclarativePlaylist::error() const
+{
+    return Error(m_error);
+}
+
+/*!
+    \qmlproperty string QtMultimedia::Playlist::errorString
+
+    This property holds a string describing the current error condition of the playlist.
+*/
+QString QDeclarativePlaylist::errorString() const
+{
+    return m_errorString;
+}
+
+/*!
+    \qmlmethod url QtMultimedia::Playlist::itemSource(index)
+
+    Returns the source URL of the item at the given \a index in the playlist.
+*/
+QUrl QDeclarativePlaylist::itemSource(int index)
+{
+    return m_playlist->media(index).canonicalUrl();
+}
+
+/*!
+    \qmlmethod int QtMultimedia::Playlist::nextIndex(steps)
+
+    Returns the index of the item in the playlist which would be current after calling next()
+    \a steps times.
+
+    Returned value depends on the size of the playlist, the current position and the playback mode.
+
+    \sa playbackMode, previousIndex()
+*/
+int QDeclarativePlaylist::nextIndex(int steps)
+{
+    return m_playlist->nextIndex(steps);
+}
+
+/*!
+    \qmlmethod int QtMultimedia::Playlist::previousIndex(steps)
+
+    Returns the index of the item in the playlist which would be current after calling previous()
+    \a steps times.
+
+    Returned value depends on the size of the playlist, the current position and the playback mode.
+
+    \sa playbackMode, nextIndex()
+*/
+int QDeclarativePlaylist::previousIndex(int steps)
+{
+    return m_playlist->previousIndex(steps);
+}
+
+/*!
+    \qmlmethod QtMultimedia::Playlist::next()
+
+    Advances to the next item in the playlist.
+*/
+void QDeclarativePlaylist::next()
+{
+    m_playlist->next();
+}
+
+/*!
+    \qmlmethod QtMultimedia::Playlist::previous()
+
+    Returns to the previous item in the playlist.
+*/
+void QDeclarativePlaylist::previous()
+{
+    m_playlist->previous();
+}
+
+/*!
+    \qmlmethod QtMultimedia::Playlist::shuffle()
+
+    Shuffles items in the playlist.
+*/
+void QDeclarativePlaylist::shuffle()
+{
+    m_playlist->shuffle();
+}
+
+/*!
+    \qmlmethod QtMultimedia::Playlist::load(location, format)
+
+    Loads a playlist from the given \a location. If \a format is specified, it is used, otherwise
+    the format is guessed from the location name and the data.
+
+    New items are appended to the playlist.
+
+    \c onloaded() is emitted if the playlist loads successfully, otherwise \c onLoadFailed() is
+    emitted with \l error and \l errorString defined accordingly.
+*/
+void QDeclarativePlaylist::load(const QUrl &location, const QString &format)
+{
+    m_error = QMediaPlaylist::NoError;
+    m_errorString = QString();
+    emit errorChanged();
+    m_playlist->load(location, format.toLatin1().constData());
+}
+
+/*!
+    \qmlmethod bool QtMultimedia::Playlist::save(location, format)
+
+    Saves the playlist to the given \a location. If \a format is specified, it is used, otherwise
+    the format is guessed from the location name.
+
+    Returns true if the playlist is saved successfully.
+*/
+bool QDeclarativePlaylist::save(const QUrl &location, const QString &format)
+{
+    return m_playlist->save(location, format.toLatin1().constData());
+}
+
+/*!
+    \qmlmethod bool QtMultimedia::Playlist::addItem(source)
+
+    Appends the \a source URL to the playlist.
+
+    Returns true if the \a source is added successfully.
+*/
+bool QDeclarativePlaylist::addItem(const QUrl &source)
+{
+    return m_playlist->addMedia(QMediaContent(source));
+}
+
+/*!
+    \qmlmethod bool QtMultimedia::Playlist::insertItem(index, source)
+
+    Inserts the \a source URL to the playlist at the given \a index.
+
+    Returns true if the \a source is added successfully.
+*/
+bool QDeclarativePlaylist::insertItem(int index, const QUrl &source)
+{
+    return m_playlist->insertMedia(index, QMediaContent(source));
+}
+
+/*!
+    \qmlmethod bool QtMultimedia::Playlist::removeItem(index)
+
+    Removed the item at the given \a index from the playlist.
+
+    Returns true if the \a source is removed successfully.
+*/
+bool QDeclarativePlaylist::removeItem(int index)
+{
+    return m_playlist->removeMedia(index);
+}
+
+/*!
+    \qmlmethod bool QtMultimedia::Playlist::clear()
+
+    Removes all the items from the playlist.
+
+    Returns true if the operation is successful.
+*/
+bool QDeclarativePlaylist::clear()
+{
+    return m_playlist->clear();
+}
+
+int QDeclarativePlaylist::rowCount(const QModelIndex &parent) const
+{
+    if (parent.isValid())
+        return 0;
+
+    return m_playlist->mediaCount();
+}
+
+QVariant QDeclarativePlaylist::data(const QModelIndex &index, int role) const
+{
+    Q_UNUSED(role);
+
+    if (!index.isValid())
+        return QVariant();
+
+    return m_playlist->media(index.row()).canonicalUrl();
+}
+
+QHash<int, QByteArray> QDeclarativePlaylist::roleNames() const
+{
+    QHash<int, QByteArray> roleNames;
+    roleNames[SourceRole] = "source";
+    return roleNames;
+}
+
+void QDeclarativePlaylist::classBegin()
+{
+    m_playlist = new QMediaPlaylist(this);
+
+    connect(m_playlist, SIGNAL(currentIndexChanged(int)),
+            this, SIGNAL(currentIndexChanged()));
+    connect(m_playlist, SIGNAL(playbackModeChanged(QMediaPlaylist::PlaybackMode)),
+            this, SIGNAL(playbackModeChanged()));
+    connect(m_playlist, SIGNAL(currentMediaChanged(QMediaContent)),
+            this, SIGNAL(currentItemSourceChanged()));
+    connect(m_playlist, SIGNAL(mediaAboutToBeInserted(int,int)),
+            this, SLOT(_q_mediaAboutToBeInserted(int,int)));
+    connect(m_playlist, SIGNAL(mediaInserted(int,int)),
+            this, SLOT(_q_mediaInserted(int,int)));
+    connect(m_playlist, SIGNAL(mediaAboutToBeRemoved(int,int)),
+            this, SLOT(_q_mediaAboutToBeRemoved(int,int)));
+    connect(m_playlist, SIGNAL(mediaRemoved(int,int)),
+            this, SLOT(_q_mediaRemoved(int,int)));
+    connect(m_playlist, SIGNAL(mediaChanged(int,int)),
+            this, SLOT(_q_mediaChanged(int,int)));
+    connect(m_playlist, SIGNAL(loaded()),
+            this, SIGNAL(loaded()));
+    connect(m_playlist, SIGNAL(loadFailed()),
+            this, SLOT(_q_loadFailed()));
+
+    if (m_playlist->isReadOnly()) {
+        m_readOnly = true;
+        emit readOnlyChanged();
+    }
+}
+
+void QDeclarativePlaylist::componentComplete()
+{
+}
+
+/*!
+    \qmlsignal QtMultimedia::Audio::itemAboutToBeInserted(start, end)
+
+    This signal is emitted when items are to be inserted into the playlist at \a start and ending at
+    \a end.
+
+    The corresponding handler is \c onItemAboutToBeInserted.
+*/
+
+/*!
+    \qmlsignal QtMultimedia::Audio::itemInserted(start, end)
+
+    This signal is emitted after items have been inserted into the playlist. The new items are those
+    between \a start and \a end inclusive.
+
+    The corresponding handler is \c onItemInserted.
+*/
+
+/*!
+    \qmlsignal QtMultimedia::Audio::itemAboutToBeRemoved(start, end)
+
+    This signal emitted when items are to be deleted from the playlist at \a start and ending at
+    \a end.
+
+    The corresponding handler is \c onItemAboutToBeRemoved.
+*/
+
+/*!
+    \qmlsignal QtMultimedia::Audio::itemRemoved(start, end)
+
+    This signal is emitted after items have been removed from the playlist. The removed items are
+    those between \a start and \a end inclusive.
+
+    The corresponding handler is \c onMediaRemoved.
+*/
+
+/*!
+    \qmlsignal QtMultimedia::Audio::itemChanged(start, end)
+
+    This signal is emitted after items have been changed in the playlist between \a start and
+    \a end positions inclusive.
+
+    The corresponding handler is \c onItemChanged.
+*/
+
+/*!
+    \qmlsignal QtMultimedia::Audio::loaded()
+
+    This signal is emitted when the playlist loading succeeded.
+
+    The corresponding handler is \c onLoaded.
+*/
+
+/*!
+    \qmlsignal QtMultimedia::Audio::loadFailed()
+
+    This signal is emitted when the playlist loading failed. \l error and \l errorString can be
+    checked for more information on the failure.
+
+    The corresponding handler is \c onLoadFailed.
+*/
+
+QT_END_NAMESPACE
+
+#include "moc_qdeclarativeplaylist_p.cpp"
diff --git a/src/imports/multimedia/qdeclarativeplaylist_p.h b/src/imports/multimedia/qdeclarativeplaylist_p.h
new file mode 100644
index 0000000..fd94135
--- /dev/null
+++ b/src/imports/multimedia/qdeclarativeplaylist_p.h
@@ -0,0 +1,199 @@
+/****************************************************************************
+**
+** Copyright (C) 2015 The Qt Company Ltd.
+** Contact: http://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL21$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see http://www.qt.io/terms-conditions. For further
+** information use the contact form at http://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 2.1 or version 3 as published by the Free
+** Software Foundation and appearing in the file LICENSE.LGPLv21 and
+** LICENSE.LGPLv3 included in the packaging of this file. Please review the
+** following information to ensure the GNU Lesser General Public License
+** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** As a special exception, The Qt Company gives you certain additional
+** rights. These rights are described in The Qt Company LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QDECLARATIVEPLAYLIST_P_H
+#define QDECLARATIVEPLAYLIST_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists for the convenience
+// of other Qt classes.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <QtCore/QAbstractListModel>
+#include <QtQml/qqmlparserstatus.h>
+#include <QtQml/qqml.h>
+
+#include <qmediaplaylist.h>
+
+QT_BEGIN_NAMESPACE
+
+class QDeclarativePlaylistItem : public QObject
+{
+    Q_OBJECT
+    Q_PROPERTY(QUrl source READ source WRITE setSource)
+
+public:
+    QDeclarativePlaylistItem(QObject *parent = 0);
+
+    QUrl source() const;
+    void setSource(const QUrl &source);
+
+private:
+    QUrl m_source;
+};
+
+class QDeclarativePlaylist : public QAbstractListModel, public QQmlParserStatus
+{
+    Q_OBJECT
+    Q_PROPERTY(PlaybackMode playbackMode READ playbackMode WRITE setPlaybackMode NOTIFY playbackModeChanged)
+    Q_PROPERTY(QUrl currentItemSource READ currentItemSource NOTIFY currentItemSourceChanged)
+    Q_PROPERTY(int currentIndex READ currentIndex WRITE setCurrentIndex NOTIFY currentIndexChanged)
+    Q_PROPERTY(int itemCount READ itemCount NOTIFY itemCountChanged)
+    Q_PROPERTY(bool readOnly READ readOnly NOTIFY readOnlyChanged)
+    Q_PROPERTY(Error error READ error NOTIFY errorChanged)
+    Q_PROPERTY(QString errorString READ errorString NOTIFY errorChanged)
+    Q_PROPERTY(QQmlListProperty<QDeclarativePlaylistItem> items READ items DESIGNABLE false)
+    Q_ENUMS(PlaybackMode)
+    Q_ENUMS(Error)
+    Q_INTERFACES(QQmlParserStatus)
+    Q_CLASSINFO("DefaultProperty", "items")
+
+public:
+    enum PlaybackMode
+    {
+        CurrentItemOnce = QMediaPlaylist::CurrentItemOnce,
+        CurrentItemInLoop = QMediaPlaylist::CurrentItemInLoop,
+        Sequential = QMediaPlaylist::Sequential,
+        Loop = QMediaPlaylist::Loop,
+        Random = QMediaPlaylist::Random
+    };
+    enum Error
+    {
+        NoError = QMediaPlaylist::NoError,
+        FormatError = QMediaPlaylist::FormatError,
+        FormatNotSupportedError = QMediaPlaylist::FormatNotSupportedError,
+        NetworkError = QMediaPlaylist::NetworkError,
+        AccessDeniedError = QMediaPlaylist::AccessDeniedError
+    };
+    enum Roles
+    {
+        SourceRole = Qt::UserRole + 1
+    };
+
+    QDeclarativePlaylist(QObject *parent = 0);
+    ~QDeclarativePlaylist();
+
+    PlaybackMode playbackMode() const;
+    void setPlaybackMode(PlaybackMode playbackMode);
+    QUrl currentItemSource() const;
+    int currentIndex() const;
+    void setCurrentIndex(int currentIndex);
+    int itemCount() const;
+    bool readOnly() const;
+    Error error() const;
+    QString errorString() const;
+    QMediaPlaylist *mediaPlaylist() const { return m_playlist; }
+
+    int rowCount(const QModelIndex &parent = QModelIndex()) const;
+    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
+    QHash<int, QByteArray> roleNames() const;
+
+    void classBegin();
+    void componentComplete();
+
+    QQmlListProperty<QDeclarativePlaylistItem> items() {
+        return QQmlListProperty<QDeclarativePlaylistItem>(
+            this, 0, item_append, item_count, 0, item_clear);
+    }
+    static void item_append(QQmlListProperty<QDeclarativePlaylistItem> *list,
+                            QDeclarativePlaylistItem* item) {
+        static_cast<QDeclarativePlaylist*>(list->object)->addItem(item->source());
+    }
+    static int item_count(QQmlListProperty<QDeclarativePlaylistItem> *list) {
+        return static_cast<QDeclarativePlaylist*>(list->object)->itemCount();
+    }
+    static void item_clear(QQmlListProperty<QDeclarativePlaylistItem> *list) {
+        static_cast<QDeclarativePlaylist*>(list->object)->clear();
+    }
+
+public Q_SLOTS:
+    QUrl itemSource(int index);
+    int nextIndex(int steps = 1);
+    int previousIndex(int steps = 1);
+    void next();
+    void previous();
+    void shuffle();
+    void load(const QUrl &location, const QString &format = QString());
+    bool save(const QUrl &location, const QString &format = QString());
+    bool addItem(const QUrl &source);
+    bool insertItem(int index, const QUrl &source);
+    bool removeItem(int index);
+    bool clear();
+
+Q_SIGNALS:
+    void playbackModeChanged();
+    void currentItemSourceChanged();
+    void currentIndexChanged();
+    void itemCountChanged();
+    void readOnlyChanged();
+    void errorChanged();
+
+    void itemAboutToBeInserted(int start, int end);
+    void itemInserted(int start, int end);
+    void itemAboutToBeRemoved(int start, int end);
+    void itemRemoved(int start, int end);
+    void itemChanged(int start, int end);
+    void loaded();
+    void loadFailed();
+
+    void error(QDeclarativePlaylist::Error error, const QString &errorString);
+
+private Q_SLOTS:
+    void _q_mediaAboutToBeInserted(int start, int end);
+    void _q_mediaInserted(int start, int end);
+    void _q_mediaAboutToBeRemoved(int start, int end);
+    void _q_mediaRemoved(int start, int end);
+    void _q_mediaChanged(int start, int end);
+    void _q_loadFailed();
+
+private:
+    Q_DISABLE_COPY(QDeclarativePlaylist)
+
+    QMediaPlaylist *m_playlist;
+    QString m_errorString;
+    QMediaPlaylist::Error m_error;
+    bool m_readOnly;
+};
+
+QT_END_NAMESPACE
+
+QML_DECLARE_TYPE(QT_PREPEND_NAMESPACE(QDeclarativePlaylistItem))
+QML_DECLARE_TYPE(QT_PREPEND_NAMESPACE(QDeclarativePlaylist))
+
+#endif
diff --git a/src/multimedia/doc/src/qtmultimedia-index.qdoc b/src/multimedia/doc/src/qtmultimedia-index.qdoc
index 6dc8942..cf26f65 100644
--- a/src/multimedia/doc/src/qtmultimedia-index.qdoc
+++ b/src/multimedia/doc/src/qtmultimedia-index.qdoc
@@ -79,6 +79,9 @@
      \li \l {QtMultimedia::Audio}{Audio}
      \li Add audio playback functionality to a scene
     \row
+     \li \l {QtMultimedia::Playlist}{Playlist}
+     \li For specifying a list of media to be played.
+    \row
      \li \l {QtMultimedia::Camera}{Camera}
      \li Access camera viewfinder frames
     \row
@@ -111,6 +114,9 @@
      \li QMediaPlayer
      \li Playback media from a source.
     \row
+     \li QMediaPlaylist
+     \li List of media to be played.
+    \row
      \li QRadioTuner
      \li Access radio device.
     \row
-- 
2.5.0

